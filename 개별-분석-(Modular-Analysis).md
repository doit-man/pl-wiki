## 개요
개별 분석은 큰 프로그램을 작은 부분으로 나누어 따로 분석한 뒤 결과를 조합하는 기술이다. 보통 함수 단위로 프로그램의 동작이 자연스럽게 나뉘기 때문에,
개별 분석에서도 주로 프로그램을 함수 단위로 나누어 분석한다. 주로 아래와 같은 절차에 따라 분석을 한다:
- 함수 호출 관계상에서 제일 말단에 위치한 함수부터 분석을 한다.
- 분석 대상 각 함수마다 입출력 관계를 파악하여 기록해둔다.
- 분석 중 다른 함수를 호출하는 지점이 오면, 미리 분석해둔 해당 함수의 입출력 관계를 활용하여 분석을 진행한다.

## 전체 분석과 개별 분석
개별 분석과 대비되는 개념은 전체 분석 (global analysis)이다. 전체 분석은 프로그램의 시작지점 (예: main 함수)부터 시작하여 프로그램의 실행순서와 비슷하게
분석을 진행하는 방식이다. 부분을 분석한 결과를 가지고 전체 분석 결과를 개별 분석이 컴파일 과정과 비슷하다면, 전체 분석은 인터프리터 (interpreter)로 프로그램을 실행하는
과정과 비슷하다고 볼 수 있다.

전체 분석과 개별 분석은 각기 장단점이 있다. 
- 전체 분석은 프로그램의 시작점부터 호출되는 함수들을 따라가면서 분석한다. 따라서, 같은 함수라도 해당 함수를 부르는 시점마다 각기 다른
함수 호출 문맥 (calling context) 으로 분석을 할 수 있다. 이런 방식은 호출 문맥에 따라 달라지는 함수의 행동을 정확하게 포착할 수 있는 장점이 있는 반면, 새로운 문맥이 관찰될 때
마다 해당 함수를 매번 분석해야하므로 느려질 수 있는 단점이 있다. 
- 개별 분석은 프로그램의 말단 함수부터 분석을 해간다. 이 때 해당 함수가 호출될 수 있는 모든 문맥을 한 번에 고려하여 분석을 한다. 그렇게 때문에 해당 분석 결과는 향후 분석 과정에서
해당 함수 호출이 있을 때 쉽게 재사용 할 수 있다. 즉, 해당 함수를 한 번만 분석해 놓으면, 그 함수를 호출하는 부분이 여러 번 등장해도 이미 분석해놓은 결과를 재사용하기만 하면 된다.
따라서, 보통 분석 속도가 빠르다. 하지만, 모든 문맥을 한 번에 고려하면서 정확하게 분석을 하기가 일반적으로 어렵다는 문제가 있다. 

## 개별 분석의 필요성
개별 분석은 지속적인 통합 (Continuous Integration)을 지향하는 현대 소프트웨어 개발 환경에서 요구되는 여러 성질을 가지고 있다:
- 서로 연관이 없는 함수들은 병렬적으로 분석할 수 있고, 한 함수는 한 번만 분석하므로 속도가 빠르다
- 일부 코드가 변했을 때 해당 부분만 다시 분석하는 점진적인 분석 (incremental analysis)을 하기 용이하다. 

## 개별 분석의 예
개별 분석을 사용하는 대표적인 예로 Facebook의 [Infer](https://fbinfer.com)가 있다.

## 참고자료
- [Inferbo: Infer-based Buffer-overrun analyzer](https://research.facebook.com/blog/2017/2/inferbo-infer-based-buffer-overrun-analyzer/)